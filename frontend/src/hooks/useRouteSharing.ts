import { useState, useCallback } from 'react';
import { RouteFeature, Location } from '../types/map';
import { Vehicle } from '../types/vehicle';
import { formatDistance, formatDuration } from '../types/map';
import { formatRouteCost } from './useRoutes';
import { toast } from 'react-hot-toast';

export interface ShareableRoute {
  id: string;
  origin: Location;
  destination: Location;
  waypoints?: Location[];
  route: RouteFeature;
  vehicle: Vehicle;
  createdAt: Date;
  expiresAt?: Date;
}

export function useRouteSharing() {
  const [isSharing, setIsSharing] = useState(false);
  const [sharedRoutes, setSharedRoutes] = useState<ShareableRoute[]>([]);

  // Generate shareable link
  const generateShareableLink = useCallback(async (
    route: RouteFeature,
    origin: Location,
    destination: Location,
    vehicle: Vehicle,
    waypoints?: Location[]
  ): Promise<string> => {
    try {
      setIsSharing(true);

      // Create route data for sharing
      const shareData = {
        origin: {
          name: origin.name,
          coordinates: origin.coordinates,
        },
        destination: {
          name: destination.name,
          coordinates: destination.coordinates,
        },
        waypoints: waypoints?.map(wp => ({
          name: wp.name,
          coordinates: wp.coordinates,
        })),
        route: {
          distance: route.properties.distance,
          duration: route.properties.duration,
          fuel_cost: route.properties.fuel_cost,
          toll_cost: route.properties.toll_cost,
          total_cost: route.properties.total_cost,
          route_type: route.properties.route_type,
        },
        vehicle: {
          name: vehicle.name,
          license_plate: vehicle.license_plate,
          fuel_consumption: vehicle.fuel_consumption,
        },
        timestamp: Date.now(),
      };

      // Encode data for URL
      const encodedData = btoa(JSON.stringify(shareData));
      const shareUrl = `${window.location.origin}/shared-route/${encodedData}`;

      // Store in local shared routes
      const shareableRoute: ShareableRoute = {
        id: encodedData,
        origin,
        destination,
        waypoints,
        route,
        vehicle,
        createdAt: new Date(),
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
      };

      setSharedRoutes(prev => [...prev, shareableRoute]);

      return shareUrl;
    } catch (error) {
      console.error('Error generating shareable link:', error);
      throw new Error('Failed to generate shareable link');
    } finally {
      setIsSharing(false);
    }
  }, []);

  // Share via Web Share API or fallback
  const shareRoute = useCallback(async (
    route: RouteFeature,
    origin: Location,
    destination: Location,
    vehicle: Vehicle,
    waypoints?: Location[]
  ) => {
    try {
      const shareUrl = await generateShareableLink(route, origin, destination, vehicle, waypoints);
      
      const shareData = {
        title: 'Route Information',
        text: `Route from ${origin.name} to ${destination.name} - ${formatDistance(route.properties.distance)}, ${formatDuration(route.properties.duration)}, ${formatRouteCost(route.properties.total_cost)}`,
        url: shareUrl,
      };

      if (navigator.share && navigator.canShare && navigator.canShare(shareData)) {
        await navigator.share(shareData);
        toast.success('Route shared successfully');
      } else {
        // Fallback: copy to clipboard
        await navigator.clipboard.writeText(shareUrl);
        toast.success('Route link copied to clipboard');
      }
    } catch (error) {
      console.error('Error sharing route:', error);
      toast.error('Failed to share route');
    }
  }, [generateShareableLink]);

  // Share as text
  const shareAsText = useCallback(async (
    route: RouteFeature,
    origin: Location,
    destination: Location,
    vehicle: Vehicle,
    waypoints?: Location[]
  ) => {
    try {
      const routeText = `
🚛 ROUTE INFORMATION

📍 From: ${origin.name}
📍 To: ${destination.name}
${waypoints && waypoints.length > 0 ? `📍 Via: ${waypoints.map(wp => wp.name).join(', ')}\n` : ''}
🛣️ Distance: ${formatDistance(route.properties.distance)}
⏱️ Duration: ${formatDuration(route.properties.duration)}
💰 Total Cost: ${formatRouteCost(route.properties.total_cost)}

🚚 Vehicle: ${vehicle.name} (${vehicle.license_plate})

Generated by Route Optimizer
      `.trim();

      if (navigator.share) {
        await navigator.share({
          title: 'Route Information',
          text: routeText,
        });
        toast.success('Route information shared');
      } else {
        await navigator.clipboard.writeText(routeText);
        toast.success('Route information copied to clipboard');
      }
    } catch (error) {
      console.error('Error sharing route as text:', error);
      toast.error('Failed to share route information');
    }
  }, []);

  // Share via email
  const shareViaEmail = useCallback((
    route: RouteFeature,
    origin: Location,
    destination: Location,
    vehicle: Vehicle,
    waypoints?: Location[]
  ) => {
    const subject = encodeURIComponent(`Route: ${origin.name} to ${destination.name}`);
    const body = encodeURIComponent(`
Route Information:

From: ${origin.name}
To: ${destination.name}
${waypoints && waypoints.length > 0 ? `Via: ${waypoints.map(wp => wp.name).join(', ')}\n` : ''}
Distance: ${formatDistance(route.properties.distance)}
Duration: ${formatDuration(route.properties.duration)}
Total Cost: ${formatRouteCost(route.properties.total_cost)}

Vehicle: ${vehicle.name} (${vehicle.license_plate})

Generated by Route Optimizer on ${new Date().toLocaleString()}
    `);

    const mailtoUrl = `mailto:?subject=${subject}&body=${body}`;
    window.open(mailtoUrl);
  }, []);

  // Share via WhatsApp
  const shareViaWhatsApp = useCallback((
    route: RouteFeature,
    origin: Location,
    destination: Location,
    vehicle: Vehicle,
    waypoints?: Location[]
  ) => {
    const message = encodeURIComponent(`
🚛 *Route Information*

📍 *From:* ${origin.name}
📍 *To:* ${destination.name}
${waypoints && waypoints.length > 0 ? `📍 *Via:* ${waypoints.map(wp => wp.name).join(', ')}\n` : ''}
🛣️ *Distance:* ${formatDistance(route.properties.distance)}
⏱️ *Duration:* ${formatDuration(route.properties.duration)}
💰 *Total Cost:* ${formatRouteCost(route.properties.total_cost)}

🚚 *Vehicle:* ${vehicle.name} (${vehicle.license_plate})

_Generated by Route Optimizer_
    `);

    const whatsappUrl = `https://wa.me/?text=${message}`;
    window.open(whatsappUrl, '_blank');
  }, []);

  // Parse shared route from URL
  const parseSharedRoute = useCallback((encodedData: string): ShareableRoute | null => {
    try {
      const decodedData = JSON.parse(atob(encodedData));
      
      return {
        id: encodedData,
        origin: {
          name: decodedData.origin.name,
          address: decodedData.origin.name,
          coordinates: decodedData.origin.coordinates,
        },
        destination: {
          name: decodedData.destination.name,
          address: decodedData.destination.name,
          coordinates: decodedData.destination.coordinates,
        },
        waypoints: decodedData.waypoints?.map((wp: any) => ({
          name: wp.name,
          address: wp.name,
          coordinates: wp.coordinates,
        })),
        route: {
          properties: {
            route_id: encodedData,
            route_type: decodedData.route.route_type,
            distance: decodedData.route.distance,
            duration: decodedData.route.duration,
            fuel_cost: decodedData.route.fuel_cost,
            toll_cost: decodedData.route.toll_cost,
            total_cost: decodedData.route.total_cost,
            color: '#3b82f6',
            weight: 4,
            opacity: 0.8,
          },
          geometry: {
            type: 'LineString',
            coordinates: [],
          },
          type: 'Feature',
        } as RouteFeature,
        vehicle: {
          id: 'shared',
          name: decodedData.vehicle.name,
          license_plate: decodedData.vehicle.license_plate,
          fuel_consumption: decodedData.vehicle.fuel_consumption,
          fuel_type: 'diesel_500',
          max_weight: 0,
          max_volume: 0,
          length: 0,
          width: 0,
          height: 0,
          company_id: '',
          is_active: true,
          created_at: new Date().toISOString(),
        },
        createdAt: new Date(decodedData.timestamp),
      };
    } catch (error) {
      console.error('Error parsing shared route:', error);
      return null;
    }
  }, []);

  // Clean up expired shared routes
  const cleanupExpiredRoutes = useCallback(() => {
    const now = new Date();
    setSharedRoutes(prev => 
      prev.filter(route => !route.expiresAt || route.expiresAt > now)
    );
  }, []);

  // Get QR code for route
  const generateQRCode = useCallback((
    route: RouteFeature,
    origin: Location,
    destination: Location,
    vehicle: Vehicle
  ): string => {
    const qrData = {
      from: origin.name,
      to: destination.name,
      distance: formatDistance(route.properties.distance),
      duration: formatDuration(route.properties.duration),
      cost: formatRouteCost(route.properties.total_cost),
      vehicle: vehicle.name,
    };
    
    const encodedData = encodeURIComponent(JSON.stringify(qrData));
    return `https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=${encodedData}`;
  }, []);

  return {
    // State
    isSharing,
    sharedRoutes,
    
    // Actions
    shareRoute,
    shareAsText,
    shareViaEmail,
    shareViaWhatsApp,
    generateShareableLink,
    generateQRCode,
    
    // Utilities
    parseSharedRoute,
    cleanupExpiredRoutes,
  };
}